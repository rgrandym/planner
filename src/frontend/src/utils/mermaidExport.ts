import { ArchNodeData, MermaidExportOptions, MermaidShapeFunction } from '@/types';
import { Edge, Node } from 'reactflow';

/**
 * Mapping of node types to Mermaid shape syntax
 * Databases -> Cylinder [(label)]
 * AI/ML -> Hexagon {{label}}
 * Logic -> Rhombus {label}
 * Documents -> Rectangle [label]
 * Default -> Rounded Rectangle (label)
 */
const MERMAID_SHAPES: Record<string, MermaidShapeFunction> = {
  // Databases -> Cylinder
  PostgreSQL: (id, label) => `${id}[(${label})]`,
  MySQL: (id, label) => `${id}[(${label})]`,
  MongoDB: (id, label) => `${id}[(${label})]`,
  Redis: (id, label) => `${id}[(${label})]`,
  Snowflake: (id, label) => `${id}[(${label})]`,

  // AI/ML -> Hexagon
  LLM: (id, label) => `${id}{{${label}}}`,
  VectorDB: (id, label) => `${id}{{${label}}}`,
  ModelTraining: (id, label) => `${id}{{${label}}}`,
  InferenceAPI: (id, label) => `${id}{{${label}}}`,
  PromptTemplate: (id, label) => `${id}{{${label}}}`,

  // Logic -> Rhombus (Diamond)
  Router: (id, label) => `${id}{${label}}`,
  Filter: (id, label) => `${id}{${label}}`,
  Loop: (id, label) => `${id}{${label}}`,
  Wait: (id, label) => `${id}{${label}}`,
  Merge: (id, label) => `${id}{${label}}`,

  // Documents/Storage -> Rectangle
  PDF: (id, label) => `${id}[${label}]`,
  CSV: (id, label) => `${id}[${label}]`,
  JSON: (id, label) => `${id}[${label}]`,
  ImageFile: (id, label) => `${id}[${label}]`,
  Markdown: (id, label) => `${id}[${label}]`,
  S3Bucket: (id, label) => `${id}[${label}]`,

  // Data Types -> Stadium/Pill shape
  String: (id, label) => `${id}([${label}])`,
  Integer: (id, label) => `${id}([${label}])`,
  Boolean: (id, label) => `${id}([${label}])`,
  Array: (id, label) => `${id}([${label}])`,
  Dictionary: (id, label) => `${id}([${label}])`,

  // Infrastructure -> Parallelogram
  WebServer: (id, label) => `${id}[/${label}/]`,
  APIGateway: (id, label) => `${id}[/${label}/]`,
  MessageQueue: (id, label) => `${id}[/${label}/]`,
  Lambda: (id, label) => `${id}[/${label}/]`,

  // Default -> Rounded Rectangle
  default: (id, label) => `${id}(${label})`,
};

/**
 * Sanitize an ID to be valid in Mermaid syntax
 * Removes spaces and special characters, replacing with underscores
 * @param id - The original ID string
 * @returns Sanitized ID safe for Mermaid
 */
function sanitizeId(id: string): string {
  return id.replace(/[^a-zA-Z0-9]/g, '_');
}

/**
 * Escape label text for Mermaid syntax
 * Handles quotes, parentheses, and special characters that break parsing
 * @param label - The label text to escape
 * @returns Escaped label string
 */
function escapeLabel(label: string): string {
  return label
    .replace(/"/g, '#quot;')
    .replace(/\n/g, '<br/>')
    .replace(/\(/g, '[')
    .replace(/\)/g, ']')
    .replace(/\{/g, '[')
    .replace(/\}/g, ']')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

/**
 * Generate Mermaid diagram code from React Flow nodes and edges
 * @param nodes - Array of React Flow nodes
 * @param edges - Array of React Flow edges
 * @param options - Export options
 * @returns Mermaid syntax string
 */
export function generateMermaidCode(
  nodes: Node<ArchNodeData>[],
  edges: Edge[],
  options: MermaidExportOptions = {}
): string {
  const { direction = 'LR', includeStyles = true } = options;

  // Generate node definitions
  const nodeLines = nodes.map((node) => {
    const cleanId = sanitizeId(node.id);
    const label = escapeLabel(node.data.label);
    const nodeType = node.data.nodeType;
    const shapeFunc = MERMAID_SHAPES[nodeType] || MERMAID_SHAPES.default;
    return `    ${shapeFunc(cleanId, label)}`;
  });

  // Generate connections
  const edgeLines = edges.map((edge) => {
    const source = sanitizeId(edge.source);
    const target = sanitizeId(edge.target);
    return `    ${source} --> ${target}`;
  });

  // Generate style definitions
  const styleLines: string[] = [];
  if (includeStyles) {
    nodes
      .filter((node) => node.data.color)
      .forEach((node) => {
        const cleanId = sanitizeId(node.id);
        styleLines.push(`    style ${cleanId} fill:${node.data.color}`);
      });
  }

  // Combine all parts
  const parts = [
    `graph ${direction}`,
    ...nodeLines,
    '',
    ...edgeLines,
  ];

  if (styleLines.length > 0) {
    parts.push('', ...styleLines);
  }

  return parts.join('\n');
}

/**
 * Generate Python code wrapped for Jupyter notebook display
 * Uses IPython.display to render Mermaid diagrams
 * Includes all necessary imports and dependencies check
 * @param nodes - Array of React Flow nodes
 * @param edges - Array of React Flow edges
 * @param options - Export options
 * @returns Python code string
 */
export function generatePythonCode(
  nodes: Node<ArchNodeData>[],
  edges: Edge[],
  options: MermaidExportOptions = {}
): string {
  const mermaidCode = generateMermaidCode(nodes, edges, options);

  return `# Generated by ArchFlow - Mermaid Diagram for Jupyter Notebook
# This code will render a Mermaid flowchart diagram in your notebook

# Method 1: Using IPython Markdown (works in VS Code, JupyterLab with mermaid extension)
from IPython.display import display, Markdown, HTML

mermaid_code = """
${mermaidCode}
"""

# Try to display using Markdown (requires mermaid extension in JupyterLab)
try:
    display(Markdown(f"\`\`\`mermaid\\n{mermaid_code}\\n\`\`\`"))
except:
    pass

# Method 2: Using mermaid.js CDN (works in any Jupyter environment)
# Uncomment the following to use the CDN-based rendering:
'''
from IPython.display import display, HTML

html_template = f"""
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>mermaid.initialize({{startOnLoad:true, theme:'dark'}});</script>
<div class="mermaid">
{mermaid_code}
</div>
"""
display(HTML(html_template))
'''`;
}

/**
 * Copy text to clipboard with fallback for older browsers
 * @param text - Text to copy
 * @returns Promise that resolves when copy is complete
 */
export async function copyToClipboard(text: string): Promise<void> {
  if (navigator.clipboard && window.isSecureContext) {
    await navigator.clipboard.writeText(text);
  } else {
    // Fallback for older browsers
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'absolute';
    textarea.style.left = '-9999px';
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand('copy');
    document.body.removeChild(textarea);
  }
}

/**
 * Validate Mermaid syntax (basic validation)
 * @param code - Mermaid code to validate
 * @returns Object with isValid flag and optional error message
 */
export function validateMermaidSyntax(code: string): {
  isValid: boolean;
  error?: string;
} {
  // Basic validation checks
  if (!code.trim()) {
    return { isValid: false, error: 'Empty diagram' };
  }

  if (!code.trim().startsWith('graph')) {
    return { isValid: false, error: 'Diagram must start with "graph"' };
  }

  // Check for balanced brackets
  const brackets: Record<string, string> = { '[': ']', '{': '}', '(': ')' };
  const stack: string[] = [];

  for (const char of code) {
    if (brackets[char]) {
      stack.push(brackets[char]);
    } else if (Object.values(brackets).includes(char)) {
      if (stack.pop() !== char) {
        return { isValid: false, error: 'Unbalanced brackets' };
      }
    }
  }

  if (stack.length > 0) {
    return { isValid: false, error: 'Unbalanced brackets' };
  }

  return { isValid: true };
}
